/*
 * Copyright (c) 2008-2016, GigaSpaces Technologies, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.gigaspaces.internal.server.space.events;

import com.gigaspaces.internal.cluster.node.IReplicationInContext;
import com.gigaspaces.internal.cluster.node.handlers.IReplicationInNotificationSentHandler;
import com.gigaspaces.internal.utils.collections.ConcurrentHashSet;
import com.j_spaces.core.OperationID;
import com.j_spaces.kernel.WorkingGroup;

import java.rmi.RemoteException;
import java.util.Iterator;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Holds a log of all the notifications that were received via replication from the primary.
 * Notifications are held until client receives them.
 *
 * @author anna
 * @since 7.0
 */
@com.gigaspaces.api.InternalApi
public class NotifyBackupLog implements IReplicationInNotificationSentHandler {
    private final WorkingGroup<RemoteEventBusPacket> _dataEventDispatcher;
    // stores notifications on backup that were not yet triggered on the primary
    private final ConcurrentHashMap<OperationID, ConcurrentHashSet<RemoteEventBusPacket>> _outgoingEvents;
    // stores events from the primary about already triggered notifications
    /// this is necessary since these events can arrive before the notifications
    private final ConcurrentHashSet<OperationID> _alreadyTriggeredEvents;

    public NotifyBackupLog(WorkingGroup<RemoteEventBusPacket> dataEventDispatcher) {
        this._dataEventDispatcher = dataEventDispatcher;
        this._outgoingEvents = new ConcurrentHashMap<OperationID, ConcurrentHashSet<RemoteEventBusPacket>>();
        this._alreadyTriggeredEvents = new ConcurrentHashSet<OperationID>();
    }

    /**
     * Stored  notify events that were generated by replication only on backup
     */
    public void add(RemoteEventBusPacket packet) {
        OperationID id = packet.getStatus().getOperationId();
        ConcurrentHashSet<RemoteEventBusPacket> outgoingEventsForOperation = _outgoingEvents.get(id);

        if (outgoingEventsForOperation == null) {
            outgoingEventsForOperation = new ConcurrentHashSet<RemoteEventBusPacket>();

            ConcurrentHashSet<RemoteEventBusPacket> previous = _outgoingEvents.putIfAbsent(id, outgoingEventsForOperation);
            if (previous != null)
                outgoingEventsForOperation = previous;
        }

        outgoingEventsForOperation.add(packet);
    }

    /**
     * Check if all notifications were received and clear them
     */
    public void clearTriggered(OperationID operationId) {
        // if all notifications were triggered both on primary and backup
        // clear the outgoing event queue
        if (operationId != null && _alreadyTriggeredEvents.contains(operationId)) {
            _outgoingEvents.remove(operationId);
            _alreadyTriggeredEvents.remove(operationId);
        }
    }

    /**
     * Clear the backup log - called when space becomes primary
     */
    public void clear() {
        _outgoingEvents.clear();
        _alreadyTriggeredEvents.clear();
    }

    @Override
    public void inNotificationSent(IReplicationInContext context, OperationID operationId)
            throws RemoteException {
        // remove all events created for this operation id            
        _alreadyTriggeredEvents.add(operationId);

        ConcurrentHashSet<RemoteEventBusPacket> notifications = _outgoingEvents.get(operationId);

        if (notifications != null && !notifications.isEmpty()) {
            Iterator<RemoteEventBusPacket> iterator = notifications.iterator();
            if (iterator.hasNext() && notifications.iterator().next().getStatus().isFinishedTemplateSearch()) {
                _outgoingEvents.remove(operationId);
                _alreadyTriggeredEvents.remove(operationId);
            }
        }
    }

    public void processOutgoingEvents() {
        for (Set<RemoteEventBusPacket> events : _outgoingEvents.values())
            for (RemoteEventBusPacket event : events)
                _dataEventDispatcher.enqueueBlocked(event);
    }
}
